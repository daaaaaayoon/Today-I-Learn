# Ch4. CPU 스케줄링

CPU는 일반적으로 한 시스템 내에 하나씩 밖에 없으므로 여러 프로그램이 동시에 수행되는 시분할 환경에서 매우 효율적으로 관리되어야하는 자원이다. CPU 자원을 관리하는 CPU 스케줄링에 대해 알아보자.

사용자 프로그램이 수행되는 과정은 두 단계로 이루어진다.

1. **CPU burst** - CPU를 직접 가지고 빠른 명령을 수행하는 단계
2. **I/O burst** - I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 단계(비교적 느림)

각 프로그램마다 CPU burst와 I/O burst가 차지하는 비율이 균일하지는 않다.

1. **CPU bound process** - I/O 요청이 빈번해 CPU burst가 짧게 나타나는 프로세스

    예) 프로세스 수행의 상당 시간을 입출력 작업 없이 CPU 작업에 소모하는 **계산 위주의 프로그램**

2. **I/O bound process** - I/O 작업을 거의 수행하지 않아 CPU burst가 길게 나타나는 프로세스

    예) 사용자로부터 인터랙션을 계속 받아가며 프로그램을 수행시키는 **대화형 프로그램**

⇒ 다양한 프로그램이 공존하므로 효율적인 CPU 기법이 필요

## 1️⃣ CPU 스케줄러

: 준비 상태에 있는 프로세스들 중 **어떤 프로세스에게 CPU를 할당할지 결정**하는 **운영체제의 코드**

**CPU 스케줄링 방식**

- **nonpreemtive** 방식 - CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 **CPU를 빼앗기지 않음**

    예) 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 blocked 상태로 바뀌는 경우, CPU에서 실행 상태에 있는 프로세스가 종료되는 경우

- **preemtive** 방식 - 프로세스가 CPU를 계속 사용하기를 원하더라도 **CPU를 강제로 빼앗을 수 있음**

    예) 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우, I/O 요청으로 blocked 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 프로세스의 상태가 준비 상태로 바뀌는 경우

## 2️⃣ Dispatcher

: 새로 선택된 프로세스가 **CPU를 할당받고 작업을 수행할 수 있도록 환경설정**을 하는 **운영체제의 코드**

1. 현재 수행중이던 프로세스의 context를 그 프로세스의 PCB에 저장
2. 새로 선택된 프로세스의 문맥 PCB로부터 복원한 후, 그 프로세스에게 CPU를 넘김
3. 시스템 상태를 사용자 모드로 전환 → 사용자 프로그램에게 CPU 제어권을 넘김

    (Program count : 현재 수행할 주소)

## 3️⃣ 스케줄링의 성능 평가

**1) 시스템 관점**

- CPU 이용률 - 전체 시간 중 CPU가 일을 한 시간의 비율
- 처리량 - 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 끝마친 작업의 수

**2) 사용자 관점**

- 소요시간 - CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 끝날 때까지 걸린 시간 (준비 큐에서 기다린 시간 + 실제 CPU를 사용한 시간)
- 대기시간 - CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
- 응답시간 - 프로세스가 준비 큐에 들어온 직후부터 첫 CPU를 획득하기까지 기다린 시간

## 4️⃣ 스케줄링 알고리즘

1. 선입선출 스케줄링 (FCFS)

    : 프로세스가 **준비 큐에 도착한 시간 순서대로 CPU를 할당**하는 방식

    - **nonpreemtive** 방식으로 할당된 프로세스가 자발적으로 CPU를 반납할 때까지 빼앗지 않음
    - 어떤 프로세스가 있느냐에 따라 대기시간(평균 대기시간)에 상당한 영향 → **비효율적**
    - **Convoy effect** 발생 - CPU burst가 짧은 프로세스가 CPU burst가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상
2. 최단작업 우선 스케줄링 (SJF)

    : **CPU burst가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당**하는 방식

    **구현**

    - nonpreemptive 방식 - CPU를 다 쓰고 나가는 시점에 스케줄링 여부를 결정
    - **preemptive 방식 (=SRTF**) - 새로운 프로세스가 도착하면 언제든지 스케줄링이 일어날 수 있음

        ⇒ **평균 대기시간을 가장 최소로** 만들어주는 최적의 알고리즘

    **문제점**

    - **Starvation** - CPU burst가 가장 짧은 프로세스가 계속 도착할 경우, CPU burst가 긴 프로세스는 영원히 CPU를 할당받지 못할 수 있음
3. 우선순위 스케줄링 (Priority)

    : 준비 큐에서 기다리는 프로세스들 중 **우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당**하는 방식

    - CPU burst 시간을 우선순위값으로 정의하면 SJF 알고리즘과 동일

    **구현**

    - nonpreemtive 방식
    - preemtive 방식 - 높은 우선순위의 프로세스가 도착하면 CPU를 빼앗을 수 있음

    **문제점**

    - **Starvation** - 우선순위가 낮은 프로세스가 계속 기다려야만하는 상황이 발생할 수 있음

        ⇒ **해결** : **Aging** - **기다리는 시간이 길어지면 우선순위를 조금씩 높여** 언젠가는 CPU를 할당받을 수 있게 해주는 방법

4. **라운드 로빈 스케줄링 (Round Robin)**

    : 각 프로세스는 **동일한 크기의 CPU 할당 시간**을 가지는 방식

    - **preemtive** 방식 - 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당

    **문제점**

    - 할당시간이 너무 길면 FCFS와 같은 결과
    - 할당시간이 너무 짧으면 문맥교환의 오버헤드가 커져 성능이 저하됨

    ⇒ 할당시간은 적당한게 좋음 10~100 milisecond

    **특징**

    - 대화형 프로세스의 빠른 응답시간을 보장할 수 있다는 장점
    - 대기시간이 CPU를 사용하려는 시간에 비례함
5. 멀티레벨 큐

    : 준비 큐를 여러 개로 분할해 관리하는 기법

6. 멀티레벨 피드백 큐 

    : CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 멀티레벨 큐와 동일하나, 프로세스 하나가 큐에서 다른 큐로 이동 가능하다는 점이 다름

## +) Thread 구현 방식

- Local - 사용자 레벨 스레드로, **사용자 프로세스가 직접 어떤 쓰레드에게 CPU를 할당할지 결정** (OS가 존재를 모름)
- Global - 커널 레벨 스레드로, **프로세스를 스케줄링 하듯이 알고리즘에 근거해서 어떤 쓰레드에게 CPU를 할당할지 결정** (OS가 알고 있음)