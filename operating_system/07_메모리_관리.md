# Ch7. 메모리 관리

## 1️⃣ 컴퓨터 주소

메모리 : 주소를 통해 접근하는 저장장치

컴퓨터는 이진수를 사용하므로 메모리 주소는 이진수로 매겨지게 된다.

우리가 흔히 사용하는 컴퓨터 시스템은 32bit 또는 64bit의 주소 체계를 사용하고 있다.

32bit → 2^32가지 메모리 위치 구분 → 2^32 byte 만큼의 메모리 공간 (컴퓨터에서는 byte단위로 메모리 주소를 부여)

1. **논리적 주소 = 가상 주소**
    - 프로세스마다 독립적으로 가지는 주소 공간으로, 각 프로세스마다 0번지부터 시작
    - CPU가 보는 주소

        미리보기) 🤔 하드웨어인 CPU가 논리적 주소를 본다고?

        ⇒ 컴파일한 코드 자체 안에 논리적 주소가 남아있음

        CPU:"주소 줘" ⇒ 주소 변환 → 물리 주소 찾아서 전달 ⇒ CPU

2. **물리적 주소**
    - 물리적 메모리에 프로세스가 실제 올라가는 위치
    - 보통 낮은 주소 영역에는 운영체제, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

## 2️⃣ 주소 바인딩 (Address Binding)

: 프로세스가 실행될 때 올라갈 물리적 메모리의 주소를 결정하는 것

### (1) 주소 바인딩 방식

분류 기준 - 물리적 메모리 주소가 결정되는 시기에 따라

<img width="440" alt="스크린샷 2021-08-25 오후 5 33 50" src="https://user-images.githubusercontent.com/53184797/130757244-3004e65d-b682-4558-831e-43a0e2db0982.png">

1. 컴파일 타임 바인딩

    : 프로그램을 컴파일할 때 물리적 메모리 주소 결정

    - 물리적 메모리의 위치를 변경하고 싶다면 컴파일을 다시 해야하는 수고가 필요
2. 로드 타임 바인딩

    : 프로그램이 시작될 때에 물리적 메모리 주소 결정

    - 로더에 책임하에 주소가 결정됨
3. **실행시간 바인딩**

    : 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 방법

    - CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블을 이용해 바인딩을 점검해야함
    - 실행시간 바인딩을 위한 하드웨어적 지원 필요 : MMU (base + limit register)

  

### (2) MMU (Memory-Management Unit)

: 논리적 주소를 물리적 주소로 매핑해주는 하드웨어

- **relocation(base) register** - 접근할 수 있는 물리적 메모리 주소의 최소값(시작값)
- **limit register** - 논리적 주소의 범위

    <img width="999" alt="스크린샷 2021-08-25 오후 5 40 47" src="https://user-images.githubusercontent.com/53184797/130758119-29738fd9-b2bb-4cf5-a5d4-3e220d5dc04e.png">

- 물리적 주소 = 논리적 주소 + base register(=relocation register)의 값
- 사용자 프로그램이나 CPU는 논리적 주소만 다룰 뿐, 실제 물리적 주소를 볼 수 없으며 알 필요도 없다.
- limit register : 메모리 보안을 위해 사용하는 레지스터

    → 트랩 → 해당 프로세스 강제 종료

    <img width="391" alt="스크린샷 2021-08-25 오후 5 34 02" src="https://user-images.githubusercontent.com/53184797/130757444-b5392d5e-5e5e-4062-94d1-ebc4b0ef6a90.png">

## 3️⃣ 메모리 관리와 관련된 용어

### (1) 동적 로딩 (Dynamic Loading)

: 프로세스의 주소 공간 전체를 메모리에 미리 다 올리는 것이 아니라 **해당 루틴이 불려질 때 그 부분만 메모리에 load하는 것**

- 여러 프로그램이 동시에 메모리에 올라가서 수행되는 **다중 프로그래밍 환경에서 메모리 사용의 효율성**을 높이기 위해 사용하는 기법
- 가끔씩 사용되는 많은 양의 코드의 경우 유용 ex) 오류 처리 루틴
- 운영체제의 특별한 지원 없이 **프로그램 자체에서 구현이 가능**하며 운영체제가 라이브러리를 통해 지원할 수도 있다.

*Loading : 메모리로 올리는 것

### (2) 동적 연결 (Dynamic Linking)

: 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 **연결을 프로그램의 실행 시점까지 지연시키는 기법**

- 라이브러리 코드가 실행 파일에 포함되지 않으며, 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어짐
- 라이브러리 호출 부분에 stub이라는 작은 코드를 두어 해당 위치를 찾을 수 있게 함

    → 호출 시, 해당 라이브러리가 메모리에 이미 존재하는지 살펴보고 그럴 경우 그 주소를 메모리 위치에서 직접 참조. 없으면 디스크에서 찾아서 적재.

- 운영체제의 지원이 필요

↔ Static linking

- 라이브러리가 프로그램의 실행 파일 코드에 포함 → 실행 파일 크기 커짐
- 동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비

*Linking : 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 object file과, 이미 컴파일된 library file들을 묶어 하나의 실행파일을 생성하는 과정

### (3) 중첩 (Overlays)

: 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법

- **작은 공간의 메모리를 사용하던** 초창기 시스템에서 수작업으로 프로그래머가 구현

vs 동적 로딩

= 다중 프로그래밍 환경에서 **메모리의 이용률을 향상**시키기 위해 당장 실행에 필요한 부분만 메모리에 올린다.

### (4) 스와핑 (Swapping)

: 프로세스를 **일시적으로 메모리에서 swap area로 쫓아내는 것**

<img width="522" alt="스크린샷 2021-08-25 오후 5 34 08" src="https://user-images.githubusercontent.com/53184797/130757456-fe259f9a-3ba0-4cd3-8c83-7fdb26bd2632.png">

- **swap area = backing store : 디스크 내 파일 시스템과는 별도로 존재하는 일정 영역**
- swap time 소요시간 = 대부분 transfer time (디스크 섹터에서 실제 데이터를 읽고 쓰는 전송 시간)

    seek time : 디스크의 탐색 시간 (스왑 영역에 순차적 저장되어서 미미한 영향)

**주소 바인딩**

- 컴파일 타임 바인딩 or 로드 타임 바인딩 - 원래 메모리 위치로 swap in 해야함.
- **실행시간 바인딩 - 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음**

## 4️⃣ 물리적 메모리의 할당 방식

### (1) 물리적 메모리 영역의 구분

- OS 상주 영역 - 인터럽트 벡터와 함께 낮은 주소 영역 사용
- 사용자 프로세스 영역 - 높은 주소 영역 사용

### (2) 사용자 프로세스 영역의 할당 방법

1. **연속 할당** - 각각의 프로세스를 메모리의 **연속적인 공간**에 올리는 방식
    1. 연속 할당의 방식

        <img width="387" alt="스크린샷 2021-08-25 오후 5 34 15" src="https://user-images.githubusercontent.com/53184797/130757595-c71daf55-12cb-443d-8a39-b1a690fd5ffe.png">

        - **고정 분할** - 물리적 메모리를 고정된 크기의 분할로 미리 나누어두는 방식 → 외부/내부조각
        - **가변 분할** - 미리 나누어놓지 않고 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식 → 외부 조각
    2. **외부/내부 조각**
        - **외부 조각** - 프로그램 크기보다 분할의 크기가 작은 경우

            → 아무 프로그램에도 **배정되지 않은** 빈 곳인데도 프로그램이 올라갈 수 없음

            - **compaction** : 외부 조각을 해결하는 한 가지 방법으로 사용 중인 메모리 영역을 한 군데로 몰고 가용 메모리 공간은 다른 한 곳으로 몰아서 사용한다. 매우 비용이 많이 드는 방법.
        - **내부 조각** - 프로그램 크기보다 분할의 크기가 큰 경우

            → 특정 프로그램에 **배정되었지만** 사용되지 않는 공간

    3. 가용 메모리 공간을 찾는 방법 (사이즈가 n인 프로그램을 위한)
        - **first fit** - 사이즈가 n 이상인 것 중 가장 먼저 찾아지는 가용 메모리 공간에 할당
        - **best fit** - 사이즈가 n 이상인 것 중 가장 작은 가용 메모리 공간에 할당
        - worst fit - 가장 큰 가용 메모리 공간에 할당
2. **불연속 할당** - 하나의 프로세스를 메모리의 **여러 영역에 분산**하여 올리는 방식
    - **페이징** - 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 적재
    - **세그먼테이션** - 코드, 데이터, 스택 등 의미있는 단위인 세그먼트로 나누어 적재
    - 페이지드 세그먼테이션 - 세그먼테이션을 기본으로 하되 이를 다시 동일 크기로 나누어 적재

## 5️⃣ 페이징 기법

: 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식

- 프로세스의 주소 공간을 물리적 메모리에 한꺼번에 올릴 필요X (일부는 백킹 스토어에, 일부는 물리적 메모리에)
- 모두 같은 크기 → 연속할당에서 발생한 동적 메모리 할당 문제 발생X
- 외부조각, 내부조각 관련
    - 모두 같은 페이지 단위 → 빈 공간 모두 활용 가능 → 외부조각 발생 가능성 X
    - 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없음 → 내부조각 발생 가능성 O

### 1) 페이지 테이블

: 각 프로세스가 주소 변환을 위해 가지고 있는 자료구조로, 프로세스가 가질 수 있는 페이지의 개수만큼 엔트리가 존재한다.

1. **주소 변환 기법**

    : CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)로 나누어 주소 변환에 사용한다.

    <img width="400" alt="스크린샷 2021-08-25 오후 5 34 21" src="https://user-images.githubusercontent.com/53184797/130757606-2f5a779e-f514-47b3-b388-3d2cc86fbbcd.png">

    - 페이지 번호 - 페이지 테이블 접근 시 인덱스 (페이지의 물리적 메모리상의 시작/기준 주소)
    - 페이지 오프셋 - 페이지 내에서의 변위 (물리적 주소 = 기준 주소값 + 변위)
2. **페이지 테이블의 구현**

    : 페이지 테이블은 **페이징 기법에서 주소 변환을 하기 위한 자료구조**로, **메인 메모리**에 위치.

    <img width="408" alt="스크린샷 2021-08-25 오후 5 34 28" src="https://user-images.githubusercontent.com/53184797/130757615-b7c28d19-1dc0-4b6d-8893-2b2c5ebe90f2.png">

    CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 OS는 2개의 레지스터를 사용함

    - 페이지 테이블 기준 레지스터 (Page-table base register) - 페이지 테이블의 시작 위치
    - 페이지 테이블 길이 레지스터 (Page-table length register) - 테이블의 크기 보관
    - **2번의 메모리 접근** 필요 (페이지 테이블 접근 1번 + data/instruction 접근 1번)

        ⇒ 오버헤드

        ⇒ 해결 : **TLB** (translation look-aside buffer)

3. **TLB** (associative register)
    - **속도 개선**을 위한 하드웨어 자원 (고속의 주소 변환용 하드웨어 캐시)
    - [논리적 주소:물리적 주소]쌍
    - 페이지 테이블에서 **빈번히 참조되는 일부 엔트리를 캐싱**하고 있음 (한 번의 메모리 접근)
    - TLB 항목 탐색에 대한 오버헤드는? → 해결 : **parallel search이 가능한 연관 레지스터 사용**
    - **TLB는 context switch 때 flush**

    <img width="384" alt="스크린샷 2021-08-25 오후 5 34 34" src="https://user-images.githubusercontent.com/53184797/130757619-c9783ed8-e750-4c1e-a21b-b05ea833b4ba.png">

### 2) 2단계 페이지 테이블

32비트 주소 체계 컴퓨터는 2^32byte(=4GB)의 주소 공간을 가진다. 페이지의 크기가 4KB(2^10=K, 2^20=M, 2^30=G)라고 한다면, 필요한 페이지 테이블의 항목은 4GB/4KB = 1M개이다.

하지만 대부분의 프로그램은 실행 시, 지극히 일부만 사용하기 때문에 메모리 공간의 낭비를 불러온다.

→ 해결 : 2단계 페이징 기법

**주소 변환**

- 외부 페이지 테이블과 내부 페이지 테이블, 두 단계에 걸친 페이지 테이블 사용
- 논리적 주소 : <외부 페이지 테이블 인덱스, 내부 페이지 테이블 인덱스, 페이지 오프셋>

    <img width="396" alt="스크린샷 2021-08-25 오후 5 34 38" src="https://user-images.githubusercontent.com/53184797/130757635-86e30a4c-44c0-4c79-b8c7-afcdb22710ee.png">

**장단점**

- 장점 - 메모리 공간의 이득

    : 사용되지 않는 주소 공간에 대해서는 외부 페이지 테이블의 항목을 NULL로 설정하며, 여기에 대응하는 **내부 페이지 테이블을 생성하지 않는다**.

- 단점 - 시간적 손해

    : 주소 변환을 위해 접근해야하는 페이지 테이블 수 증가

## 6️⃣ 세그먼테이션

: 주소 공간을 기능 단위 또는 의미를 가질 수 있는 논리적인 단위로 나눈 것. → 크기 불균형

**논리적 주소**

- 세그먼트 번호 - 해당 논리적 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는지
- 오프셋 - 세그먼트 내에서 얼마만큼 떨어져 있는지

**주소 변환**

- 세그먼트 테이블
    - 세그먼트 테이블 기준 레지스터(STBR) - 물리적 메모리에서 그 세그먼트의 시작 위치
    - 세그먼트 테이블 길이 레지스터(STLR) - 그 세그먼트의 길이/개수 (세그먼트의 크기가 균일하지 않기 때문에)
- 주소 변환 전 확인 작업
    1. 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인가?
    2. 요청된 오프셋 값이 그 세그먼트의 길이보다 작은 값인가?

    → 만족하지 않는 경우, 예외 상황 발생 → 해당 메모리 위치 접근 봉쇄

    <img width="399" alt="스크린샷 2021-08-25 오후 5 34 49" src="https://user-images.githubusercontent.com/53184797/130757651-f492bfc9-e311-415d-a901-6984801e6022.png">

**장단점**

- **장점** - 의미 단위 의미 부여로 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적.
- **단점** - 크기가 균일하지 않아서 물리적 메모리 관리에서 외부 조각 발생, 세그먼트를 어느 가용공간에 할당할 것인지 결정하는 문제 발생
    - first fit - 해당 세그먼트의 크기보다 크거나 같은 첫번째 가용 공간 사용
    - best fit - 해당 세그먼트의 크기보다 크거나 같은 가용 공간 중 가장 작은 공간 사용