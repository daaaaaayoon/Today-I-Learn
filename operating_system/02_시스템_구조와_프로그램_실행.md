# Ch2. 시스템 구조와 프로그램 실행

운영체제를 본격적으로 시작하기 전에, 

컴퓨터 시스템이 어떻게 동작하고, 프로그램들이 하드웨어 위에서 어떻게 돌아가는지 알아보자.

## 1. 컴퓨터 시스템 구조

: 컴퓨터(CPU, Memory)가 호스트이며, 입출력 장치(하드디스크, 키보드/마우스, 프린터, 모니터 등)와 정보를 주고 받는다. 그 사이에는 DMA 컨트롤러와 타이머가 있다.

<img width="485" alt="스크린샷 2021-08-13 오후 2 00 09" src="https://user-images.githubusercontent.com/53184797/129307317-e1d6d28b-240f-4222-9f1b-7358aa05cdf2.png">

- **CPU** - 매 clock 마다 Memory에서 instruction(기계어)을 읽어와 실행. 한 instruction이 끝나면 interrupt liine을 검사한다.

    입출력 장치에 직접 접근하지 않고, 메모리에만 접근한다. 입출력 장치를 해야할 때에는 해당 입출력 장치의 장치 제어기에게 일을 시키고 다음 일을 수행한다.

    매우 빠르며, 사용자 입장에서는 interactive한 응답을 받을 수 있음

    - **register** - 메모리보다 빠르게 정보를 저장하는 작은 공간
    - **mode** **bit** - 지금 CPU를 사용하고 있는 주체가 운영체제인지 사용자 프로그램인지 구분
    - **interrupt line** - 입출력 관련 interrupt가 발생한 경우, 발생한 interrupt를 확인
- **memory** - CPU의 작업 공간
- **입출력 장치** - 정보를 입력받고 출력하는 장치
    - **device controller**(장치 제어기) - 각 입출력 장치를 전담하는 일종의 **작은 CPU.** 각 장치의 어떤 부분에서 어떤 내용을 읽어올지 담당. (입출력 장치 속도가 CPU에 비해 매우 느리기 때문에 필요)
    - **local buffer** - device controller의 작업 공간 (일종의 메모리 역할)
- **timer** - 특정 프로그램이 CPU를 독점하는 것으로부터 보호함. (OS가 작업을 CPU에 넘겨주기 전 timer에 시간을 걸고, 시간이 끝나면 timer interrupt 발생, OS가 주도권을 다시 가져감)
- **DMA** **controller** - CPU의 중재 없이 데이터를 전송하고, 작업이 완료되면 interrupt를 걸어 CPU에게 알려준다.

### 🖥 Mode bit

: 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기위한 **보호 장치**.

두 가지 모드의 operation 지원
<img width="462" alt="스크린샷 2021-08-13 오후 2 00 12" src="https://user-images.githubusercontent.com/53184797/129307344-0cda3d6c-7594-4f0a-b16c-8e45b2730ed4.png">


- **1 - 사용자 모드** ⇒ 사용자 프로그램 수행
- **0 - 커널 모드** ⇒ OS 코드 수행

Interrupt나 Exception 발생 시 하드웨어가 mode bit을 0으로 세팅한다.

사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅한다.

### 🖥 Timer

: CPU를 특정 프로그램이 독점하는 것으로부터 보호

정해진 시간이 흐른 뒤, OS에게 제어권이 넘어가도록 interrupt를 발생시킨다.

타이머는 매 clock tick 마다 1씩 감소하며 타이머 값이 0이 되면 timer interrupt 발생

### 🖥 I/O Device Controller

: 해당 I/O 장치 유형을 관리하는 일종의 **작은 CPU**

제어 정보를 위해 control register, status register를 가지고, 일종의 data register인 local buffer를 가진다.

I/O는 실제 device와 local buffer 사이에서 일어남 →  I/O가 끝났을 경우 interrupt로 CPU에게 알림

### 🖥 I/O 수행

모든 입출력은 특권 명령이다.

사용자 프로그램이 입출력을 하기 위해서는,

1. **시스템 콜** 발생 - 사용자 프로그램은 운영체제에게 I/O 요청 → mode bit이 1에서 0으로 변경됨
    - 시스템 콜 : 사용자 프로그램이 OS의 서비스를 받기 위해 커널 함수를 호출하는 것
2. **trap**을 사용하여 인터럽트 벡터의 특정 위치로 이동
3. 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
4. 올바른 I/O 요청인지 확인 후, I/O 수행
5. I/O 완료 시, 제어권을 시스템 콜 다음 명령으로 이동

### 🖥 interrupt

포괄적인 의미로, 일반적 의미는 하드웨어가 발생시킨 인터럽트이다.

**시스템 콜 / Exception**으로 프로그램이 오류를 범한 경우에는 소프트웨어 인터럽트를 발생시키는데, 이를 **Trap**이라고 한다.

- **인터럽트 벡터** - **인터럽트 번호 + 주소 쌍**. 해당 **인터럽트의 처리 루틴 주소**를 가지고 있음.
- **인터럽트 처리 루틴** (인터럽트 서비스 루틴, 인터럽트 핸들러) - 해당 인터럽트를 처리하는 커널 함수로 **실제 해야할 일**을 의미

⇒ 인터럽트 당한 시점의 레지스터와 프로그램 카운터를 저장한 후, CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

⇒ 현대 운영체제는 interrupt 구조에 의해 구동된다. interrupt가 걸릴 때만 OS가 CPU를 가진다.

### 🖥 동기식 입출력과 비동기식 입출력

- 동기식 입출력(Synchronous I/O) - I/O 요청 후, 작업이 완료된 후에야 사용자 프로그램으로 제어가 넘어가는 방식. (다른 일을 수행하지 않고 기다리며, 결과를 보고 나서야 다음 작업을 수행)
- 비동기식 입출력(Asynchronous I/O) - I/O가 시작된 후, 작업이 끝나기를 기다리지 않고, 제어가 사용자 프로그램에 즉시 넘어가는 방식. (입출력과는 무관한 일처럼)

### 🖥 DMA(Direct Memory Access)

: 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용. CPU를 거치지 않고 device controller가 장치의 buffer storage 내용을 메모리에 block 단위로 직접 전송 (not byte 단위)

전송이 완료되면, DMA 모듈은 CPU로 인터럽트 신호를 보낸다. 따라서 CPU는 전송의 시작과 끝만 관여함.

인터럽트 구동 방식보다 효율적

### 🖥 저장장치 계층 구조
<img width="549" alt="스크린샷 2021-08-13 오후 2 07 48" src="https://user-images.githubusercontent.com/53184797/129307615-3030d5df-de75-401c-88cd-58a5a78f5548.png">


1. Primary storage - CPU가 직접 접근해서 처리 가능 (Executable, byte 단위), 휘발성
    - Cache Memory - 중간에서 속도 완충 (캐싱 : 빠른 매체로 자주 사용하는 정보를 재사용하기위해 복사해서 올려둔다.)
    - Main Memory -  DRAM
2. Secondary storage - CPU가 직접 접근해서 처리 못함, 비휘발성

→ 상위 단계일수록 속도가 빠른 매체를 사용하며, 비싸고 용량이 적다.

## 2. 프로그램의 실행

<img width="447" alt="스크린샷 2021-08-13 오후 1 59 57" src="https://user-images.githubusercontent.com/53184797/129307383-8736e543-58d0-49ff-899b-3f3b6cb7e545.png">

일반 프로그램은 파일 시스템(하드 디스크, 비휘발성 디스크)내에 실행파일 형태로 저장되어 있음

이 실행파일을 실행시키면 메모리에 올라가 프로세스가 된다.

(정확히는 가상 메모리를 거쳐서 물리적 메모리로 올려서 실행시킨다. 논리적 메모리 주소가 물리적 메모리 주소로 변환된다.)

<img width="482" alt="스크린샷 2021-08-13 오후 2 00 02" src="https://user-images.githubusercontent.com/53184797/129307388-8959ac3f-7c93-4026-be26-fda73f564407.png">

1. 프로그램을 실행하면 그 프로그램의 독자적인 메모리 주소공간(stack, data, code로 구성된)이 생김.
    - stack - 데이터를 쌓거나 빼는 용도
    - data - 변수/자료구조를 담고 있음
    - code - 기계어 코드를 담고 있음
2. 당장 필요한 것만 물리적 메모리에 올리고, 그렇지 않은 부분은 디스크의 swap area(비휘발성)에 놓는다.

부팅 시, 커널 영역은 메모리에 항상 상주해 있지만 사용자 프로그램의 주소공간은 프로그램 종료 시 사라진다.

### 커널 주소 공간

<img width="476" alt="스크린샷 2021-08-13 오후 1 59 48" src="https://user-images.githubusercontent.com/53184797/129307453-2246c3e3-d0b3-44db-9e24-8764e9da1498.png">


- **code** (커널 코드)
    - 시스템 콜, 인터럽트 처리 코드
    - 자원 관리를 위한 코드
    - 서비스 제공을 위한 코드
- **data** (OS가 사용하는 자료구조들)
    - CPU, memory, disk와 같은 하드웨어를 관리하기 위해 각각의 자료구조를 가지고 있음.
    - 프로세스들을 관리하기 위해 각 프로세스마다 자료구조(PCB)를 가짐.
- **stack** (함수 호출 시 사용)
    - 사용자 프로그램마다(프로세스마다) 커널 스택을 따로 가지고 있음

### **사용자** 프로그램이 사용하는 함수

- **사용자** **정의 함수** - 자신의 프로그램에서 정의한 함수 (내가 직접 작성한 함수를 불러와서 사용한다.)
- **라이브러리** **함수** - 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수

    → 사용자 정의 함수와 라이브러리 함수 둘 다 자신의 프로그램 실행파일에 포함되어 있다. 사용자 프로세스의 code영역 내에서 점프하며 실행됨.

- **커널** **함수** - OS 프로그램의 함수. 사용자가 가지고 있지 않고, 커널 함수를 호출하여 쓴다. (가상 메모리 내에서 점프할 수 없으므로, interrupt line을 세팅하고 system call)

### 프로그램의 실행

프로그램 A의 입장에서,

<img width="467" alt="스크린샷 2021-08-13 오후 1 59 51" src="https://user-images.githubusercontent.com/53184797/129307456-f011bebb-9aed-46bf-a21b-8ece49e1920f.png">

### Reference
[운영체제 강의 - 이화여자대학교 반효경](http://www.kocw.net/home/search/kemView.do?kemId=1046323)