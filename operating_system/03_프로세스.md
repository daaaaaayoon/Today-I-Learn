# Ch3. 프로세스

## 1. 프로세스의 개념

### 1) 프로세스

: 실행중인 프로그램으로, 디스크에 실행파일 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 프로세스가 된다.

### 2) 프로세스 문맥

: **프로세스의** 현재 **상태**를 나타내는데 필요한 모든 **요소**

문맥의 분류)
<img width="475" alt="스크린샷 2021-08-10 오후 8 31 57" src="https://user-images.githubusercontent.com/53184797/128860153-ed16fb73-d372-40d6-94d8-1d3e7bc928ef.png">


- 하드웨어 문맥 - CPU 수행 상태를 나타내는 것(프로그램 카운터 값, 각종 레지스터 저장 값 등)
- 프로세스의 주소 공간 - 코드, 데이터, 스택
- 프로세스 관련 커널 자료구조 - 커널 주소 공간에 있는 PCB(프로세스 관리를 위한 자료구조), 커널 스택

## 2. 프로세스의 상태

프로세는 **자원을 효율적으로 관리**하기 위해 상태를 구분하며, 상태가 변경되며 수행된다.
<img width="500" alt="스크린샷 2021-08-10 오후 8 32 01" src="https://user-images.githubusercontent.com/53184797/128860409-086dedb6-020e-40b9-a125-221d4bcda56e.png">

- **Running(실행)** - CPU 보유하고 instruction 수행중인 상태
- **Ready(준비)** - CPU를 기다리는 상태로, CPU만 보유하면 instruction 실행이 가능한 상태 (메모리 등 다른 조건을 모두 만족)
- **Blocked(봉쇄, wait, sleep)** - CPU를 할당 받더라도 당장 instruction을 수행할 수 없는 상태 ex) 입출력 작업 진행중 (디스크에서 file을 읽어와야 하는 경우)

New(시작) - 프로세스가 생성중인 상태, 프로세서가 시작되어 각종 자료구조는 생성되었지만 아직 메모리 획득은 승인 못받은 상태

Terminated(완료) - 수행이 끝난 상태, 프로세스가 종료되었으나 운영체제가 자료구조를 완전히 정리하지 못한 상태

## 3. 프로세스 제어블록 (PCB)

: Process Control Block, OS가 시스템 내의 프로세스들을 관리하기 위해 **프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조**

<img width="495" alt="스크린샷 2021-08-10 오후 8 31 43" src="https://user-images.githubusercontent.com/53184797/128860560-20595ea9-e75a-4e96-bbf1-bf000adf3d1c.png">

- 프로세스의 상태 - CPU를 할당해도 되는지 여부를 결정하기 위함
- 프로그램 카운터의 값 - 다음에 수행할 명령의 위치를 가리킴
- CPU 레지스터의 값 - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지
- CPU 스케줄링 정보
- 메모리 관리 정보
- 자원 사용 정보
- 입출력 상태 정보

프로세스가 실행되다가 본인이 할 수 없는 일을 운영체제에게 해달라고 함 → **커널**도 함수형태라서 스택에서 어떤 프로세스가 호출했는지에 따라서 별도의 **스택**을 두고 수행

## 4. 문맥 교환

: Context Switch, 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 넘겨지는 과정 (수행중이던 프로세스의 문맥을 저장하고, 새로운 프로세스의 문맥을 세팅)

- CPU가 다른 프로세스에게 넘어갈 때 OS는 다음을 수행한다.
    - CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
    - CPU를 새롭게 얻는 프로세스의 상태를 해당 프로세스의 PCB에서 읽어옴

<img width="480" alt="스크린샷 2021-08-10 오후 8 31 47" src="https://user-images.githubusercontent.com/53184797/128860396-5d7edb34-fcaf-4057-a3ce-6ec62869f26f.png">

### 1) 문맥 교환의 발생

ex) 타이머 인터럽트, 입출력 요청 시스템 콜

1. 타이머 인터럽트

    <img width="488" alt="스크린샷 2021-08-10 오후 8 31 07" src="https://user-images.githubusercontent.com/53184797/128860538-c8bec5c8-491a-46ec-85b9-85fb544ef1a3.png">

2. 입출력 요청 시스템 콜

    <img width="495" alt="스크린샷 2021-08-10 오후 8 31 23" src="https://user-images.githubusercontent.com/53184797/128860557-a880cad0-16d1-4469-9914-dc19821bc77d.png">

### 2) 문맥 교환이 아닌 경우와 문맥 교환인 경우

-시스템 콜이나 인터럽트 발생 시, 반드시 context switch가 일어나는 것은 아님

<img width="496" alt="스크린샷 2021-08-10 오후 8 21 04" src="https://user-images.githubusercontent.com/53184797/128860550-0cbdd724-5493-4701-9b3e-92c88af5fd59.png">


문맥교환이 없는 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 저장해야하지만

문맥교환을 하는 경우에는 부담이 훨씬 크다.

## 5. 프로세스를 스케줄링하기 위한 큐

: 하드웨어 또는 소프트웨어 자원을 기다리는 프로세스들을 줄 세우는 역할

이러한 프로세스의 상태 관리는 **커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 수행**함

<img width="525" alt="스크린샷 2021-08-12 오후 12 12 53" src="https://user-images.githubusercontent.com/53184797/129133033-90328617-dcb0-4258-9411-568f97fa0ceb.png">

**큐의 종류**

- Job queue - 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready queue - 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device queues - I/O device의 처리를 기다리는 프로세스의 집합

**큐의 자료구조**

: 각 프로세스의 PCB를 연결 리스트 형태로 관리 + 포인터를 사용해 순서를 정함

## 6. 스케줄러

: 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드

### 스케줄러 종류

- Long-term scheduler

    : 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할

    : 어떤 프로세스에 메모리 및 각종 자원을 줄지를 정함 

    = (장기 스케줄러, Job scheduler)

    → 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할

- **Short-term scheduler**

    : 준비 상태의 프로세스 중 어떤 프로세스를 running할지 결정하는 역할

    : 어떤 프로세스에 CPU를 할당할지를 정함 

    = (단기 스케줄러, CPU scheduler)

    → 빈번히 호출되기 때문에 빨라야함

- **Medium-Term scheduler**

    : 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크의 스왑영역으로 쫓아내는 역할 (스왑 아웃)

    : 어떤 프로세스에게서 메모리를 빼았을지 정함

    = (중기 스케줄러, Swapper)

    → 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할

### 중기 스케줄러의 등장 → 프로세스의 상태 + 중지 상태

**중지 상태(suspended, stopped)**

: 외부적인 이유로 프로세스의 수행이 정지된 상태로, 통째로 디스크에 swap out된다

ex) 사용자가 프로그램을 일시 정지시킨 경우, 시스템이 여러 이유로 프로세스를 잠시 중단시킴 (메모리에 너무 많은 프로세스가 올라와 있을 때)

<img width="526" alt="스크린샷 2021-08-12 오후 12 13 04" src="https://user-images.githubusercontent.com/53184797/129132912-53ff14ba-6a53-49c1-8347-08f8d8c79f21.png">
]

- blocked : 자신이 요청한 event가 만족되면 ready
- suspended : 외부에서 resume해 주어야 active

## 7. 프로세스의 생성

: 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음부터는 **이미 존재하는 프로세스가 다른 프로세스의 주소 공간을 그대로 복제한 후, 생성된 공간 위에 새로운 프로그램의 주소 공간을 덮어씌워 실행**

: 이때 프로세스를 생성한 프로세스를 부모 프로세스라고 하고, 새롭게 생성된 프로세스를 자식 프로세스라고 한다.

-트리(계층 구조) 생성

### **프로세스의 자원**

- 부모와 자식이 모든 자원 공유하는 모델
- 일부를 공유하는 모델
- 전혀 공유하지 않는 모델

+) Copy-On-Write(COM) - 모든 것을 다 복사하는 것이 아닌 처음 Program Counter 하나만 복사하고 나머지는 공유 → write가 발생했을 때 각자 저장 공간을 가짐

### **프로세스의 수행**

- 부모와 자식이 공존하며 수행되는 모델

    → 자식과 부모가 같이 CPU를 획득하기 위해 경쟁하는 관계

- 자식이 종료될 때까지 부모가 기다리는(wait) 모델

    → 자식 프로세스가 종료될 때까지 부모 프로세스는 아무 일도 하지않고 blocked 상태에 머물러 있다가 자식 프로세스가 종료되면 다시 CPU를 얻을 권한 생김

### **시스템 콜** (OS에게 부탁) - **fork(), exec(), wait(), exit(), abort()**

- **fork()** - **부모 프로세스**의 주소 공간의 내용을 그대로 **복사**해서 **자식 프로세스 생성** (process ID를 제외한 모든 정보 복제, program counter까지 복사해서 수행 시점까지 같음)
- **exec()** - 복사된 자식 프로세스의 주소 공간에 완전히 **새로운 프로그램을 올림**
- **wait()** - 자식 프로세스가 종료되길 기다리며 부모 프로세스를 blocked 상태로

    → 부모 프로세스와 자식 프로세스 간의 동기화 가능

- **exit()**
    - 자발적 종료 - 운영체제에게 자신이 종료됨을 알림 (종료 지점 자동 삽입)
    - 비자발적 종료 - 부모가 자식 프로세스의 수행을 강제 종료
        1. 한계를 넘어선 자원 요구
        2. 더 이상 필요하지 않은 경우
        3. 부모가 exit()된 경우 (→ 단계적 종료)

## 8. 프로세스 간의 협력

프로세스는 각자 자신만의 독립적인 주소 공간을 가지고 수행되며 정보를 주고 받을 수 있는 방법이 없다.

→ 운영체제는 **프로세스 간의 협력 매커니즘**을 제공해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있게 한다. (처리 결과 정보 공유 or  처리 속도 향상 등의 효과성)

### IPC(Inter-Process Communication)

: 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신

why? 공유 데이터를 서로 다른 두 프로세스가 사용할 수 있다면 데이터의 불일치 문제 발생 가능성 있음

1. **메시지 전달 방식 (message passing)**

    : 운영체제의 **커널**을 통해 메시지를 전달

    - 직접 - 프로세스 이름 명시
    - 간접 - 메일 박스 또는 포트
2. **공유 메모리 방식 (shared memory)**

    : 프로세스들이 주소 공간의 일부를 공유

    커널에게 말하면 메모리 주소 매핑 시 일부 영역이 공유되도록 설정됨

    → 동기화 문제는 알아서 책임져야함

    <img width="432" alt="스크린샷 2021-08-12 오후 12 13 12" src="https://user-images.githubusercontent.com/53184797/129132917-5013b114-3ba7-46fc-bb6b-902bbf45a327.png">


## 9. Thread

: CPU를 수행하는 단위 - 하나의 프로세스에 여러개의 쓰레드

- Thread의 구성 - program counter, register set, stack space
- Thread가 동료 Thread와 공유하는 부분 - code, data, OS resources

<img width="602" alt="스크린샷 2021-08-12 오후 12 13 17" src="https://user-images.githubusercontent.com/53184797/129132927-2476ed14-9945-4e57-a4dd-076948675bd2.png">

⇒ 메모리 적게 사용

### 다중 Thread 사용

**장점**

- **응답성** - 웹 브라우저에서 주소를 치면 html 문서를 웹 브라우저 화면에 display 할 때, 이미지를 다시 서버에 요청(오래 걸리는 작업 : process의 block → nono 이제는 thread)하는 동안 다른 thread가 미리 불러온 텍스트를 디스플레이 (일종의 비동기식 입출력)
- **자원의** **공유** - 자원을 효율적으로 쓰는 효과 (메모리 적게 사용)
- **빠름 -** 프로세스 하나 만들기는 오버헤드 큼, 스레드를 하나 만드는 것은 오버헤드가 그렇게 크지는 않음, 프로세스의 문맥교환 속도 < 스레드의 문맥교환 속도

    스레드간의 CPU 스위치는 간단함 (동일한 주소공간) - 대부분의 문맥 사용 가능

    ⇒ 스레드를 생성하고 CPU Switching을 하는 것이 프로세스를 생성하고 문맥 교환을 하는 것보다 효율적

**단점** 

- 여러개의 스레드가 프로세스의 자원(code, data, stack)을 같이 사용 → **데이터에 대한 일관성 문제**가 생김

    ⇒ 접근하는 공유자원에 대해서 **동기화** 해줘야함.

## etc. 동기식 입출력과 비동기식 입출력 부연 설명

프로세스가 입출력이 진행되는 동안에 CPU를 가진건 중요하지 않음

- 입출력이 끝날때까지 기다리면 : 동기식
- 입출력이 안끝났는데 instruction 실행 : 비동기식