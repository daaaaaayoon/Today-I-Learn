# Ch3. 프로세스

## 1. 프로세스의 개념

### 1) 프로세스

: 실행중인 프로그램으로, 디스크에 실행파일 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 프로세스가 된다.

### 2) 프로세스 문맥

: **프로세스의** 현재 **상태**를 나타내는데 필요한 모든 **요소**

문맥의 분류)
<img width="475" alt="스크린샷 2021-08-10 오후 8 31 57" src="https://user-images.githubusercontent.com/53184797/128860153-ed16fb73-d372-40d6-94d8-1d3e7bc928ef.png">


- 하드웨어 문맥 - CPU 수행 상태를 나타내는 것(프로그램 카운터 값, 각종 레지스터 저장 값 등)
- 프로세스의 주소 공간 - 코드, 데이터, 스택
- 프로세스 관련 커널 자료구조 - 커널 주소 공간에 있는 PCB(프로세스 관리를 위한 자료구조), 커널 스택

## 2. 프로세스의 상태

프로세는 **자원을 효율적으로 관리**하기 위해 상태를 구분하며, 상태가 변경되며 수행된다.
<img width="500" alt="스크린샷 2021-08-10 오후 8 32 01" src="https://user-images.githubusercontent.com/53184797/128860409-086dedb6-020e-40b9-a125-221d4bcda56e.png">

- **Running(실행)** - CPU 보유하고 instruction 수행중인 상태
- **Ready(준비)** - CPU를 기다리는 상태로, CPU만 보유하면 instruction 실행이 가능한 상태 (메모리 등 다른 조건을 모두 만족)
- **Blocked(봉쇄, wait, sleep)** - CPU를 할당 받더라도 당장 instruction을 수행할 수 없는 상태 ex) 입출력 작업 진행중 (디스크에서 file을 읽어와야 하는 경우)

New(시작) - 프로세스가 생성중인 상태, 프로세서가 시작되어 각종 자료구조는 생성되었지만 아직 메모리 획득은 승인 못받은 상태

Terminated(완료) - 수행이 끝난 상태, 프로세스가 종료되었으나 운영체제가 자료구조를 완전히 정리하지 못한 상태

## 3. 프로세스 제어블록 (PCB)

: Process Control Block, OS가 시스템 내의 프로세스들을 관리하기 위해 **프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조**

<img width="495" alt="스크린샷 2021-08-10 오후 8 31 43" src="https://user-images.githubusercontent.com/53184797/128860560-20595ea9-e75a-4e96-bbf1-bf000adf3d1c.png">

- 프로세스의 상태 - CPU를 할당해도 되는지 여부를 결정하기 위함
- 프로그램 카운터의 값 - 다음에 수행할 명령의 위치를 가리킴
- CPU 레지스터의 값 - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지
- CPU 스케줄링 정보
- 메모리 관리 정보
- 자원 사용 정보
- 입출력 상태 정보

프로세스가 실행되다가 본인이 할 수 없는 일을 운영체제에게 해달라고 함 → **커널**도 함수형태라서 스택에서 어떤 프로세스가 호출했는지에 따라서 별도의 **스택**을 두고 수행

## 4. 문맥 교환

: Context Switch, 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 넘겨지는 과정 (수행중이던 프로세스의 문맥을 저장하고, 새로운 프로세스의 문맥을 세팅)

- CPU가 다른 프로세스에게 넘어갈 때 OS는 다음을 수행한다.
    - CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
    - CPU를 새롭게 얻는 프로세스의 상태를 해당 프로세스의 PCB에서 읽어옴

<img width="480" alt="스크린샷 2021-08-10 오후 8 31 47" src="https://user-images.githubusercontent.com/53184797/128860396-5d7edb34-fcaf-4057-a3ce-6ec62869f26f.png">

### 1) 문맥 교환의 발생

ex) 타이머 인터럽트, 입출력 요청 시스템 콜

1. 타이머 인터럽트

    <img width="488" alt="스크린샷 2021-08-10 오후 8 31 07" src="https://user-images.githubusercontent.com/53184797/128860538-c8bec5c8-491a-46ec-85b9-85fb544ef1a3.png">

2. 입출력 요청 시스템 콜

    <img width="495" alt="스크린샷 2021-08-10 오후 8 31 23" src="https://user-images.githubusercontent.com/53184797/128860557-a880cad0-16d1-4469-9914-dc19821bc77d.png">

### 2) 문맥 교환이 아닌 경우와 문맥 교환인 경우

-시스템 콜이나 인터럽트 발생 시, 반드시 context switch가 일어나는 것은 아님

<img width="496" alt="스크린샷 2021-08-10 오후 8 21 04" src="https://user-images.githubusercontent.com/53184797/128860550-0cbdd724-5493-4701-9b3e-92c88af5fd59.png">


문맥교환이 없는 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 저장해야하지만

문맥교환을 하는 경우에는 부담이 훨씬 크다.