## π§ ν•¨μν• ν”„λ΅κ·Έλλ°

### 1) ν•¨μν• μΈν„°νμ΄μ¤λ€?

- Funtional Interface
- μ¶”μƒ λ©”μ†λ“λ¥Ό λ”± ν•λ‚λ§ κ°€μ§€κ³  μλ” μΈν„°νμ΄μ¤
- SAM(Single Abstract Method) μΈν„°νμ΄μ¤
- @Funtionalinterface μ• λ…Έν…μ΄μ…μ„ κ°€μ§€κ³  μλ” μΈν„°νμ΄μ¤

```java
// ν•¨μν• μΈν„°νμ΄μ¤ : λ‹¨ ν•λ‚μ μ¶”μƒ λ©”μ†λ“λ§ κ°€μ§ μ μμ 
// -> λ¬Έλ²•μ„ μ–΄κΈΈ μ‹, μ–΄λ…Έν…μ΄μ…μ„ ν†µν•΄ μ»΄νμΌ κ³Όμ •μ—μ„ μ¤λ¥ ν™•μΈ κ°€λ¥
@FunctionalInterface
public interface RunSomething {

    // abstract ν‚¤μ›λ“ μƒλµ κ°€λ¥ (κµ¬ν„μ²΄λ¥Ό λ§λ“¤ λ• λ°λ“μ‹ κµ¬ν„ν•΄μ•Όν•¨)
    void doIt();

    // λ‹¤λ¥Έ ν•νƒμ λ©”μ†λ“ μ‚¬μ© κ°€λ¥. ν•μ§€λ§ λ‹¤λ¥Έ abstract λ©”μ†λ“ λ¶κ°€
    static void first() {
        System.out.println("first");
    }

    default void second() {
        System.out.println("second");
    }

}
```

### 2) λλ‹¤ ν‘ν„μ‹

- Lambda Expressions
- ν•¨μν• μΈν„°νμ΄μ¤μ μΈμ¤ν„΄μ¤λ¥Ό λ§λ“¤ μ μλ” λ°©λ²•μΌλ΅ μ“°μΌ μ μλ‹¤.
- μ½”λ“λ¥Ό μ¤„μΌ μ μλ‹¤.
- λ©”μ†λ“ λ§¤κ°λ³€μ, λ¦¬ν„΄ νƒ€μ…, λ³€μλ΅ λ§λ“¤μ–΄ μ‚¬μ©ν•  μλ„ μλ‹¤.

```java
// μµλ… λ‚΄λ¶€ ν΄λμ¤ : anonymous inner class
RunSomething runSomething1 = new RunSomething() {
     @Override
     public void doIt() {
         System.out.println("do it 1");
     }
};
// λλ‹¤ ν‘ν„μ‹μΌλ΅ λ³€κ²½
RunSomething runSomething2 = () -> System.out.println("do it 2");

runSomething1.doIt(); // do it 1
runSomething2.doIt(); // do it 2
```

### 3) μλ°”μ—μ„μ ν•¨μν• ν”„λ΅κ·Έλλ°

- ν•¨μλ¥Ό First class objectλ΅ μ‚¬μ©ν•  μ μλ‹¤.
- μμ ν•¨μ
    - μ‚¬μ΄λ“ μ΄ν™νΈκ°€ μ—†λ‹¤. (ν•¨μ λ°–μ— μλ” κ°’μ„ λ³€κ²½ν•μ§€ μ•λ”λ‹¤.)
    - μƒνƒκ°€ μ—†λ‹¤. (ν•¨μ λ°–μ— μλ” κ°’μ„ μ‚¬μ©ν•μ§€ μ•λ”λ‹¤.)
- κ³ μ°¨ ν•¨μ
    - ν•¨μκ°€ ν•¨μλ¥Ό λ§¤κ°λ³€μλ΅ λ°›μ„ μ μκ³  ν•¨μλ¥Ό λ¦¬ν„΄ν•  μλ„ μλ‹¤.
- λ¶λ³€μ„±



## 1οΈβƒ£ μλ°” κΈ°λ³Έ μ κ³µ ν•¨μν• μΈν„°νμ΄μ¤

- μλ°”μ—μ„ λ―Έλ¦¬ μ •μν•΄λ‘” μμ£Ό μ‚¬μ©ν• λ§ν• ν•¨μ μΈν„°νμ΄μ¤
- **java.lang.function ν¨ν‚¤μ§€**
- μΆ…λ¥
    - Function<T, R>
    - BiFunction<T, U, R>
    - Consumer<T>
    - Supplier<T>
    - Predicate<T>
    - UnaryOperator<T>
    - BinaryOperator<T>

1. **Function<T, R>**
    - T νƒ€μ…μ„ λ°›μ•„μ„ R νƒ€μ…μ„ λ¦¬ν„΄ν•λ” ν•¨μ μΈν„°νμ΄μ¤
    - μ‚¬μ© : R apply(T t)
    - ν•¨μ μ΅°ν•©μ© λ©”μ†λ“
        - compose : μ•
        - andThen : λ’¤

    ```java
    // ν•¨μν• μΈν„°νμ΄μ¤ Function μ‚¬μ©ν•κΈ° (apply λ©”μ†λ“)

    // Function μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” Plus10 class
    public class Plus10 implements Function<Integer, Integer> {
        @Override
        public Integer apply(Integer integer) {
            return integer + 10;
        }
    }

    Plus10 plus10 = new Plus10();
    System.out.println(plus10.apply(10));      // 20

    // λλ‹¤ ν‘ν„μ‹μΌλ΅ κ°„λ‹¨ν•κ²
    Function<Integer, Integer> plus10simple = i -> i+10;
    System.out.println(plus10simple.apply(10)); // 20

    Function<Integer, Integer> multiply = i -> i*2;
    System.out.println(multiply.apply(10));     // 20

    // μ΅°ν•©ν•λ” λ©”μ†λ“ :compose
    // compose μ•μ λ©”μ†λ“λ¥Ό λ¨Όμ € μ μ© -> κ²°κ³Όκ°’μ„ plus10μ μ…λ ¥κ°’μΌλ΅ μ‚¬μ©
    Function<Integer, Integer> multiplyAndPlus10 = plus10.compose(multiply);
    System.out.println(multiplyAndPlus10.apply(10));   // 30

    // plus10 μ μ© ν›„ andThen μ•μ λ©”μ†λ“ μ μ© -> plus10μ κ²°κ³Όκ°’μ„ multiplyμ μ…λ ¥κ°’μΌλ΅ μ‚¬μ©
    Function<Integer, Integer> plus10AndMultiply = plus10.andThen(multiply);
    System.out.println(plus10AndMultiply.apply(10));   // 40
    ```

1. **BiFunction<T, U, R>**
    - λ‘ κ°μ κ°’ T, Uλ¥Ό λ°›μ•„μ„ Rνƒ€μ…μ„ λ¦¬ν„΄ν•λ” ν•¨μ μΈν„°νμ΄μ¤
    - = Function<T, R> μΈν„°νμ΄μ¤μ— μ…λ ¥κ°’μ΄ λ‘ κ°μΈ ν•¨μ μΈν„°νμ΄μ¤
    - μ‚¬μ© : R apply(T t, U u)

2. **Consumer<T>**
    - T νƒ€μ…μ„ λ°›μ•„μ„ μ•„λ¬΄κ°’λ„ λ¦¬ν„΄ν•μ§€ μ•λ” ν•¨μ μΈν„°νμ΄μ¤
    - μ‚¬μ© : void accpet(T t)
    - ν•¨μ μ΅°ν•©μ© λ©”μ†λ“ : andThen

    ```java
    Consumer<Integer> consumer = i -> System.out.println(i);
    consumer.accept(2);   // 2
    ```

3. **Supplier<T>**
    - T νƒ€μ…μ κ°’μ„ μ κ³µν•λ” ν•¨μ μΈν„°νμ΄μ¤ (μ…λ ¥κ°’μ΄ μ—†μ)
    - μ‚¬μ© : T get()

    ```java
    Supplier<Integer> get10 = () -> 3;
    System.out.println(get10.get());  // 3
    ```

1. **Predicate<T>**
    - T νƒ€μ…μ„ λ°›μ•„μ„ booleanμ„ λ¦¬ν„΄ν•λ” ν•¨μ μΈν„°νμ΄μ¤
    - μ‚¬μ© : boolean test(T t)
    - ν•¨μ μ΅°ν•©μ© λ©”μ†λ“
        - and
        - or
        - negate

    ```java
    Predicate<String> startWithBoo = (s) -> s.startsWith("Boo");
    System.out.println(startWithBoo.test("Boorang"));   // true
            
    Predicate<Integer> isOdd = (i) -> i%2 != 0;
    System.out.println(isOdd.test(10));                 // false
    ```

1. **UnaryOperator<T>**
    - Function<T, R>μ νΉμν• ν•νƒλ΅, μ…λ ¥κ°’ ν•λ‚λ¥Ό λ°›μ•„μ„ λ™μΌν• νƒ€μ…μ„ λ¦¬ν„΄ν•λ” ν•¨μ μΈν„°νμ΄μ¤
    - μ…λ ¥κ°’μ νƒ€μ…κ³Ό λ¦¬ν„΄κ°’μ νƒ€μ…μ΄ λ™μΌν•  λ• μ‚¬μ©

2. **BinaryOperator<T>**
    - BiFunction<T>μ νΉμν• ν•νƒλ΅, λ™μΌν• νƒ€μ…μ μ…λ ¥κ°’ λ‘ κ°λ¥Ό λ°›μ•„ λ¦¬ν„΄ν•λ” ν•¨μ μΈν„°νμ΄μ¤
    - μ…λ ¥κ°’μ΄ 2κ°μ΄λ©° νƒ€μ…μ΄ λ¦¬ν„΄κ°’μ νƒ€μ…κ³Ό λ™μΌν•  λ• μ‚¬μ©

## 2οΈβƒ£ λλ‹¤ ν‘ν„μ‹

**(μΈμ λ¦¬μ¤νΈ) β†’ {λ°”λ””}**

### 1) μΈμ λ¦¬μ¤νΈ

- μΈμκ°€ μ—†μ„  λ• : ()
- μΈμκ°€ ν• κ° : (one) λλ” one
- μΈμκ°€ μ—¬λ¬κ° : (one, two)
- μΈμμ νƒ€μ…μ€ μƒλµ κ°€λ¥, μ»΄νμΌλ¬κ°€ μ¶”λ΅ ν•μ§€λ§ λ…μ‹λ„ κ°€λ¥ (Integer one, Integer two)

### 2) λ°”λ””

- ν™”μ‚΄ν‘ μ¤λ¥Έμ½μ— ν•¨μ λ³Έλ¬Έμ„ μ •μν•λ” κ³³
- μ—¬λ¬ μ¤„μΈ κ²½μ° {}λ¥Ό μ‚¬μ©ν•΄μ„ λ¬¶μ
- ν• μ¤„μΈ κ²½μ°μ— μƒλµ κ°€λ¥, returnλ„ μƒλµ κ°€λ¥

### 3) λ³€μ μΊ΅μ³

- **effective final**
    - μ‚¬μ‹¤μƒ finalμΈ λ³€μ
    - final ν‚¤μ›λ“λ¥Ό μ‚¬μ©ν•μ§€ μ•μ€ λ³€μλ¥Ό μµλ… ν΄λμ¤ κµ¬ν„μ²΄ λλ” λλ‹¤μ—μ„ μ°Έμ΅°ν•  μ μλ‹¤.
- **λ΅μ»¬ λ³€μ μΊ΅μ³**
    - final μ΄κ±°λ‚ effective finalμΈ κ²½μ°μ—λ§ μ°Έμ΅° κ°€λ¥
    - κ·Έλ ‡μ§€ μ•μ„ κ²½μ° concurrency λ¬Έμ κ°€ μƒκΈΈ μ μμ–΄μ„ μ»΄νμΌλ¬κ°€ λ°©μ§€ν•¨

    ```java
    private void run() {
            
        // λ³€κ²½λμ§€μ•λ” μ‚¬μ‹¤μƒ final λ³€μ : effective final
        int bNum = 10;

        IntConsumer printInt = (i) -> {
            System.out.println(i + bNum);
        };
            
        printInt.accept(10);
            
        // μ£Όμ„ ν•΄μ λλ©΄, final λ³€μκ°€ μ•„λ‹κΈ° λ•λ¬Έμ— λλ‹¤μ‹μ—μ„ μ»΄νμΌ μ¤λ¥ λ°μƒ
        // λ‚΄μ© : Variable used in lambda expression should be final and effectively final.
    //        bNum++;
            
    }
    ```

- **μµλ… ν΄λμ¤ κµ¬ν„μ²΄μ™€ λ‹¬λ¦¬ 'μ‰λ„μ‰'μ„ ν•μ§€ μ•λ”λ‹¤.**
    - μ‰λ„μ‰ : μƒλ΅μ΄ scopeμ΄ λ°–μ— μλ” λ³€μλ¥Ό κ°€λ¦°λ‹¤.
    - μµλ… ν΄λμ¤λ” μƒλ΅ scopeμ„ λ§λ“¤μ§€λ§, λλ‹¤λ” λλ‹¤λ¥Ό κ°μ‹Έκ³  μλ” scopeκ³Ό κ°™λ‹¤.

## 3οΈβƒ£ λ©”μ†λ“ λ νΌλ°μ¤ ::

- λλ‹¤κ°€ ν•λ” μΌμ΄ κΈ°μ΅΄ λ©”μ†λ“ λλ” μƒμ„±μλ¥Ό νΈμ¶ν•λ” κ²ƒμ΄λΌλ©΄, λ©”μ†λ“ λ νΌλ°μ¤λ¥Ό μ‚¬μ©ν•΄μ„ λ§¤μ° κ°„κ²°ν•κ² ν‘ν„ κ°€λ¥

### **λ©”μ†λ“ μ°Έμ΅°ν•λ” λ°©λ²•**

![image](https://user-images.githubusercontent.com/53184797/127856153-f4fe64ad-e0a6-41a1-a16a-4e63444d7b7f.png)


- λ©”μ†λ“ λλ” μƒμ„±μμ λ§¤κ°λ³€μλ΅ λλ‹¤μ μ…λ ¥κ°’μ„ λ°›λ”λ‹¤.
- λ¦¬ν„΄κ°’ λλ” μƒμ„±ν• κ°μ²΄λ” λλ‹¤μ λ¦¬ν„΄κ°’μ΄λ‹¤.

```java
// 1. static λ©”μ†λ“ μ°Έμ΅°
UnaryOperator<String> hi = Greeting::hi;
hi.apply("Boo");

// 2. νΉμ • κ°μ²΄μ μΈμ¤ν„΄μ¤ λ©”μ†λ“ μ°Έμ΅°
Greeting greeting = new Greeting();
UnaryOperator<String> hello = greeting::hello;
hello.apply("Jeju");

// 3. μ„μ κ°μ²΄μ μΈμ¤ν„΄μ¤ λ©”μ†λ“ μ°Έμ΅°
String[] names = {"jeju", "kyul", "boo", "svt"};
// κΈ°μ΅΄ μ„μ κ°μ²΄ -> λλ‹¤ ν‘ν„μ‹μΌλ΅ λ³€κ²½ κ°€λ¥ -> λ©”μ†λ“ λ νΌλ°μ¤ μ‚¬μ© κ°€λ¥
Arrays.sort(names, new Comparator<String>() {
		@Override
		public int compare(String o1, String o2) {
		      return 0;
		}
});
// λλ‹¤ ν‘ν„μ‹μΌλ΅ λ³€κ²½
Arrays.sort(names, (o1, o2) -> 0);
// λ©”μ†λ“ λ νΌλ°μ¤ μ‚¬μ© - Stringμ λ©”μ†λ“κ°€ μ•„λ‹λΌ μ„μ κ°μ²΄μ λ©”μ†λ“ compareToλ¥Ό μ°Έμ΅°ν• κ²ƒμ„
Arrays.sort(names, String::compareTo);
Arrays.stream(names).forEach(System.out::println); // boo jeju kyul svt

// 4. μƒμ„±μ μ°Έμ΅°
// μ…λ ¥κ°’μ΄ μ—†κ³  λ¦¬ν„΄κ°’μ΄ GreetingμΈ Supplier => νλΌλ―Έν„° μ—†λ” μƒμ„±μ μ°Έμ΅°
Supplier<Greeting> jejuGreeting = Greeting::new;

// μ…λ ¥κ°’μ΄ Stringμ΄κ³  λ¦¬ν„΄κ°’μ΄ Greeting => νλΌλ―Έν„°κ°€ μλ” μƒμ„±μ μ°Έμ΅°
Function<String, Greeting> booGreeting = Greeting::new;
Greeting boo = booGreeting.apply("Boo");
System.out.println(boo.getName());    // Boo

```